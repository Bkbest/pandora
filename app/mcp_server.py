import contextlib
import os
from pathlib import Path
from typing import List

import uvicorn
from mcp.server.fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.middleware import Middleware
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.routing import Mount

from .sandbox_manager import SandboxManager


APP_ROOT = Path(__file__).resolve().parent.parent
SANDBOX_ROOT = Path(os.environ.get("SANDBOX_ROOT", str(APP_ROOT / "sandboxes"))).resolve()
DOCKER_IMAGE = os.environ.get("SANDBOX_PYTHON_IMAGE", "python:3.11-slim")
CONTAINER_PREFIX = os.environ.get("SANDBOX_CONTAINER_PREFIX", "code-sandbox")
WORKDIR_IN_CONTAINER = "/workspace"
NETWORK_DISABLED = os.environ.get("SANDBOX_NETWORK_DISABLED", "0").lower() in ("1", "true", "yes")

MCP_HOST = os.environ.get("MCP_HOST", "0.0.0.0")
MCP_PORT = int(os.environ.get("MCP_PORT", "3000"))

manager = SandboxManager(
    sandbox_root=SANDBOX_ROOT,
    docker_image=DOCKER_IMAGE,
    container_prefix=CONTAINER_PREFIX,
    workdir_in_container=WORKDIR_IN_CONTAINER,
    network_disabled=NETWORK_DISABLED,
)

mcp = FastMCP(
    "Pandora Sandbox",
    instructions="Docker-backed sandbox manager for running Python code generated by AI agents.",
    stateless_http=True,
    json_response=True,
    host=MCP_HOST
)


@mcp.tool()
def create_sandbox() -> dict:
    """Create a new sandbox.

    Creates:
    - A sandbox workspace directory on the host
    - A dedicated Docker container with the workspace bind-mounted

    Returns:
    - id: sandbox identifier
    """

    sandbox_id = manager.create_sandbox()
    return {"id": sandbox_id}


@mcp.tool()
def delete_sandbox(id: str) -> dict:
    """Delete a sandbox and clean up all resources.

    Removes:
    - The Docker container for the sandbox
    - The sandbox workspace directory (including uploaded files and installed packages)
    """

    manager.delete_sandbox(id)
    return {"ok": True}


@mcp.tool()
def list_sandbox_files(id: str, dir: str = "/") -> dict:
    """List files in a sandbox.

    Args:
    - id: sandbox identifier
    - dir: directory within the sandbox workspace (e.g. '/', '/project')

    Returns:
    - files: list of file paths relative to the sandbox root
    """

    files = manager.list_files(id, dir)
    return {"files": files}


@mcp.tool()
def upsert_file(id: str, path: str, content: str) -> dict:
    """Create or update a file in the sandbox workspace."""

    manager.upsert_file(id, path, content)
    return {"ok": True}


@mcp.tool()
def delete_file(id: str, path: str) -> dict:
    """Delete a file from the sandbox workspace."""

    manager.delete_file(id, path)
    return {"ok": True}


@mcp.tool()
def execute(id: str, path: str = "main.py", args: List[str] | None = None) -> dict:
    """Execute a Python file inside the sandbox container.

    Only `.py` files can be executed.

    Args:
    - id: sandbox identifier
    - path: path to a `.py` file in the sandbox workspace
    - args: command-line args passed to the Python program

    Returns:
    - exit_code, stdout, stderr
    """

    exit_code, stdout, stderr = manager.execute(id, path, args or [])
    return {"exit_code": exit_code, "stdout": stdout, "stderr": stderr}


@mcp.tool()
def install_packages(id: str, packages: List[str]) -> dict:
    """Install Python packages into the sandbox.

    Packages are installed using pip into `/workspace/.python_packages` so they persist for the sandbox.
    The execute tool sets `PYTHONPATH` accordingly.

    Args:
    - id: sandbox identifier
    - packages: pip requirement strings, e.g. ['requests==2.32.3', 'numpy']

    Returns:
    - exit_code, stdout, stderr
    """

    exit_code, stdout, stderr = manager.install_packages(id, packages)
    return {"exit_code": exit_code, "stdout": stdout, "stderr": stderr}


@contextlib.asynccontextmanager
async def lifespan(app: Starlette):
    async with mcp.session_manager.run():
        yield


if not hasattr(mcp, "streamable_http_app"):
    raise RuntimeError(
        "Installed 'mcp' package does not support Streamable HTTP. "
        "Upgrade to a newer MCP Python SDK (e.g. 'mcp>=1.2.0')."
    )

app = Starlette(
    routes=[
        Mount("/", app=mcp.streamable_http_app()),
    ],
    lifespan=lifespan,
    )


def main() -> None:
    # Configure uvicorn to allow requests from any host
    # Set environment variable to disable host validation
    os.environ["PYTHONUNBUFFERED"] = "1"
    
    uvicorn.run(
        app, 
        host=MCP_HOST, 
        port=MCP_PORT,
        # Allow requests from any IP/host - disable strict host checking
        server_header=False,
        access_log=False,
        # Additional settings to allow cross-origin and host header flexibility
        ws_ping_interval=None,
        ws_ping_timeout=None,
    )


if __name__ == "__main__":
    main()
