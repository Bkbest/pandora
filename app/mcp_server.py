import contextlib
import os
from pathlib import Path
from typing import List

import uvicorn
from mcp.server.fastmcp import FastMCP
from starlette.applications import Starlette
from starlette.middleware import Middleware
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.routing import Mount

from .sandbox_manager import SandboxManager


APP_ROOT = Path(__file__).resolve().parent.parent
SANDBOX_ROOT = Path(os.environ.get("SANDBOX_ROOT", str(APP_ROOT / "sandboxes"))).resolve()
DOCKER_IMAGE = os.environ.get("SANDBOX_PYTHON_IMAGE", "python:3.11-slim")
CONTAINER_PREFIX = os.environ.get("SANDBOX_CONTAINER_PREFIX", "code-sandbox")
WORKDIR_IN_CONTAINER = "/workspace"
NETWORK_DISABLED = os.environ.get("SANDBOX_NETWORK_DISABLED", "0").lower() in ("1", "true", "yes")

MCP_HOST = os.environ.get("MCP_HOST", "0.0.0.0")
MCP_PORT = int(os.environ.get("MCP_PORT", "3000"))

manager = SandboxManager(
    sandbox_root=SANDBOX_ROOT,
    docker_image=DOCKER_IMAGE,
    container_prefix=CONTAINER_PREFIX,
    workdir_in_container=WORKDIR_IN_CONTAINER,
    network_disabled=NETWORK_DISABLED,
)

mcp = FastMCP(
    "Pandora Sandbox",
    instructions="Docker-backed sandbox manager for running Python code generated by AI agents.",
    stateless_http=True,
    json_response=True,
    host=MCP_HOST
)


@mcp.tool()
def create_sandbox() -> dict:
    """Create a new sandbox.

    Creates:
    - A sandbox workspace directory on host
    - A dedicated Docker container with workspace bind-mounted

    Returns:
    - id: sandbox identifier
    
    Errors:
    - error: error message if creation fails
    """

    try:
        sandbox_id = manager.create_sandbox()
        return {"success": True, "id": sandbox_id}
    except Exception as e:
        return {"success": False, "error": str(e), "error_type": type(e).__name__}


@mcp.tool()
def delete_sandbox(id: str) -> dict:
    """Delete a sandbox and clean up all resources.

    Removes:
    - The Docker container for the sandbox
    - The sandbox workspace directory (including uploaded files and installed packages)
    
    Errors:
    - error: error message if deletion fails
    """

    try:
        manager.delete_sandbox(id)
        return {"success": True, "message": "Sandbox deleted successfully"}
    except Exception as e:
        return {"success": False, "error": str(e), "error_type": type(e).__name__}


@mcp.tool()
def list_sandbox_files(id: str, dir: str = "/") -> dict:
    """List files in a sandbox.

    Args:
    - id: sandbox identifier
    - dir: directory within the sandbox workspace (e.g. '/', '/project')

    Returns:
    - files: list of file paths relative to the sandbox root
    
    Errors:
    - error: error message if listing fails
    """

    try:
        files = manager.list_files(id, dir)
        return {"success": True, "files": files}
    except Exception as e:
        return {"success": False, "error": str(e), "error_type": type(e).__name__}


@mcp.tool()
def upsert_file(id: str, path: str, content: str) -> dict:
    """Create or update a file in the sandbox workspace.
    
    Errors:
    - error: error message if file operation fails
    """

    try:
        manager.upsert_file(id, path, content)
        return {"success": True, "message": f"File '{path}' created/updated successfully"}
    except Exception as e:
        return {"success": False, "error": str(e), "error_type": type(e).__name__}


@mcp.tool()
def delete_file(id: str, path: str) -> dict:
    """Delete a file from the sandbox workspace.
    
    Errors:
    - error: error message if deletion fails
    """

    try:
        manager.delete_file(id, path)
        return {"success": True, "message": f"File '{path}' deleted successfully"}
    except Exception as e:
        return {"success": False, "error": str(e), "error_type": type(e).__name__}


@mcp.tool()
def read_file_from_sandbox(id: str, path: str) -> dict:
    """Read the contents of a file from the sandbox workspace.
    
    Args:
    - id: sandbox identifier
    - path: path to the file in the sandbox workspace
    
    Returns:
    - content: file contents as text
    - size: file size in bytes
    
    Errors:
    - error: error message if file read fails
    """

    try:
        content = manager.read_file(id, path)
        return {
            "success": True,
            "content": content,
            "size": len(content.encode('utf-8')),
            "message": f"File '{path}' read successfully"
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "error_type": type(e).__name__,
            "content": "",
            "size": 0
        }


@mcp.tool()
def execute(id: str, path: str = "main.py", args: List[str] | None = None) -> dict:
    """Execute a Python file inside the sandbox container.
    
    Only `.py` files can be executed.

    Args:
    - id: sandbox identifier
    - path: path to a `.py` file in the sandbox workspace
    - args: command-line args passed to the Python program

    Returns:
    - exit_code, stdout, stderr
    
    Errors:
    - error: error message if execution fails
    """

    try:
        exit_code, stdout, stderr = manager.execute(id, path, args or [])
        return {
            "success": True,
            "exit_code": exit_code,
            "stdout": stdout,
            "stderr": stderr,
            "message": "Execution completed"
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "error_type": type(e).__name__,
            "exit_code": -1,
            "stdout": "",
            "stderr": str(e)
        }


@mcp.tool()
def install_packages(id: str, packages: List[str]) -> dict:
    """Install Python packages into the sandbox.
    
    Packages are installed using pip into `/workspace/.python_packages` so they persist for the sandbox.
    The execute tool sets `PYTHONPATH` accordingly.

    Args:
    - id: sandbox identifier
    - packages: pip requirement strings, e.g. ['requests==2.32.3', 'numpy']

    Returns:
    - exit_code, stdout, stderr
    
    Errors:
    - error: error message if installation fails
    """

    try:
        exit_code, stdout, stderr = manager.install_packages(id, packages)
        return {
            "success": True,
            "exit_code": exit_code,
            "stdout": stdout,
            "stderr": stderr,
            "message": f"Package installation completed for: {', '.join(packages)}"
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "error_type": type(e).__name__,
            "exit_code": -1,
            "stdout": "",
            "stderr": str(e)
        }


@contextlib.asynccontextmanager
async def lifespan(app: Starlette):
    async with mcp.session_manager.run():
        yield


if not hasattr(mcp, "streamable_http_app"):
    raise RuntimeError(
        "Installed 'mcp' package does not support Streamable HTTP. "
        "Upgrade to a newer MCP Python SDK (e.g. 'mcp>=1.2.0')."
    )

app = Starlette(
    routes=[
        Mount("/", app=mcp.streamable_http_app()),
    ],
    lifespan=lifespan,
    )


def main() -> None:
    # Configure uvicorn to allow requests from any host
    # Set environment variable to disable host validation
    os.environ["PYTHONUNBUFFERED"] = "1"
    
    uvicorn.run(
        app, 
        host=MCP_HOST, 
        port=MCP_PORT,
        # Allow requests from any IP/host - disable strict host checking
        server_header=False,
        access_log=False,
        # Additional settings to allow cross-origin and host header flexibility
        ws_ping_interval=None,
        ws_ping_timeout=None,
    )


if __name__ == "__main__":
    main()
